# 📝 알고리즘 문제 해결 가이드

## 📌 1. 문제 유형을 빠르게 판별하는 방법

### ✅ ① 입력 크기를 분석하자
- **입력 크기가 크다면 (`N ≥ 10⁶`)** → `O(N log N)` 또는 `O(N)` 알고리즘 사용
    - **이진 탐색, 해시, DP (메모이제이션), 투 포인터**
- **입력 크기가 작다면 (`N ≤ 1000`)** → `O(N²)`도 가능
    - **완전 탐색, DFS/BFS, DP**
- **입력 크기가 매우 작다면 (`N ≤ 10`)** → `O(N!)`도 가능
    - **백트래킹, 순열/조합, 비트마스킹**

---

### ✅ ② 최적해(최댓값/최솟값)를 구하는 문제인가?
- **"최대" 또는 "최소"를 찾는 문제**  
  → **그리디 / DP / 이진 탐색 / 그래프 최단경로**
- **"가능 여부(Yes/No)"를 묻는 문제**  
  → **이진 탐색 / BFS / DFS**

---

### ✅ ③ 문제에서 요구하는 "조건"을 분석하자
#### 🔹 **중복된 계산을 피해야 하는 문제 (DP)**
- "이전 계산 결과를 활용할 수 있는가?" → **DP**
- "큰 문제를 작은 문제로 나눠서 풀 수 있는가?" → **점화식 설정**
- **예시 문제**
    - "N번째 피보나치 수 구하기" → **DP / 재귀**
    - "가장 짧은 편집 거리(최소 비용) 구하기" → **DP**
    - "배낭 문제 (최대 가치 찾기)" → **DP (Knapsack)**

---

#### 🔹 **최적의 경로를 찾아야 하는 문제 (그래프 탐색)**
- **"길 찾기, 최소 비용, 최대 비용"**  
  → **BFS / 다익스트라 / 플로이드 워셜 / 벨만-포드**
- **예시 문제**
    - "미로에서 최단 경로 찾기" → **BFS**
    - "도시 간 최소 이동 비용 찾기" → **다익스트라**
    - "모든 정점에서 모든 정점으로 가는 최소 비용" → **플로이드-워셜**

---

#### 🔹 **빠르게 검색해야 하는 문제 (이진 탐색 / 해시)**
- **"정렬된 데이터에서 특정 값을 찾아야 함"** → **이진 탐색**
- **"여러 개의 쿼리를 빠르게 처리해야 함"** → **해시맵 / 이진 탐색 / 세그먼트 트리**
- **예시 문제**
    - "N개의 수가 주어질 때 특정 수가 존재하는지 찾기" → **이진 탐색**
    - "빈번한 쿼리가 들어오는 경우" → **해시맵**

---

#### 🔹 **경우의 수를 모두 따져봐야 하는 문제 (완전 탐색 / 백트래킹)**
- **"모든 경우를 다 따져봐야 하나?"** → 완전 탐색을 고려
- **"가능한 모든 조합을 만들어야 하는가?"** → **백트래킹 / 순열 / 조합**
- **예시 문제**
    - "N개의 숫자로 만들 수 있는 모든 조합을 찾아라" → **백트래킹 / 조합**
    - "가능한 모든 경로를 찾아라" → **DFS + 백트래킹**

---

#### 🔹 **슬라이딩 윈도우 / 투 포인터가 적절한 경우**
- **"연속된 부분 배열을 다룬다."** → **슬라이딩 윈도우**
- **"두 개의 포인터를 이용해서 최적해를 찾아야 한다."** → **투 포인터**
- **예시 문제**
    - "연속된 부분 배열의 최댓값 찾기" → **슬라이딩 윈도우**
    - "정렬된 두 배열에서 중복되지 않는 원소 찾기" → **투 포인터**

---

#### 🔹 **그리디 알고리즘이 적절한 경우**
- **"항상 최적의 선택을 하면서 문제를 풀 수 있는가?"**  
  → "최댓값을 만드는 문제" 또는 "최소 비용으로 해결하는 문제"
- **예시 문제**
    - "동전 최소 개수로 거스름돈 만들기" → **그리디**
    - "강의실 배정 문제 (최대 개수 선택)" → **그리디 (최소 종료 시간 기준 정렬)**

---

#### 🔹 **정렬을 사용하면 쉽게 풀리는 문제**
- **"큰 값부터 처리해야 하는가?"** → **내림차순 정렬**
- **"가장 작은 값부터 사용해야 하는가?"** → **오름차순 정렬**
- **예시 문제**
    - "회의실을 최대한 많이 배정하는 문제" → **그리디 + 정렬**
    - "가장 효율적으로 데이터를 정렬하여 해결하는 문제" → **정렬 + 투 포인터**

---

## 🚀 2. 알고리즘 선택 흐름표
✔ **입력 크기를 본다.**  
✔ **최댓값, 최솟값을 찾는 문제인지 확인한다.**  
✔ **문제에서 요구하는 조건을 분석한다.**

### 🔹 예제 문제 분석
1️⃣ **"길이가 N인 배열이 주어질 때, 부분 배열 중 합이 K인 경우의 수를 구하시오."**
- 부분 배열이 나오면 **슬라이딩 윈도우 / 투 포인터**
- 특정 합을 찾는다면 **해시맵 + 누적합** 고려

2️⃣ **"N개의 강의가 주어지고, 최소한의 강의실을 사용해야 한다."**
- 시간 순서대로 **그리디 + 정렬 (최소 종료 시간 기준)**

3️⃣ **"N개의 수가 주어질 때, 특정 수를 빠르게 찾으시오."**
- 빠르게 찾아야 하면 **이진 탐색 / 해시맵**

---

## 🚀 3. 많이 나오는 알고리즘 유형 정리
| 유형 | 대표 알고리즘 |
|------|-------------|
| **탐색** | DFS / BFS / 이진 탐색 |
| **최적해** | 다익스트라 / 그리디 / DP |
| **조합** | 백트래킹 / 비트마스킹 |
| **부분 배열** | 투 포인터 / 슬라이딩 윈도우 |
| **경우의 수** | DP / 백트래킹 |
| **빠른 검색** | 이진 탐색 / 해시맵 |

---

## 🚀 4. 결론
✔ **입력 크기, 최댓값/최솟값, 문제 조건을 분석하면 빠르게 알고리즘을 정할 수 있음.**  
✔ **패턴을 익히면 "이 문제는 이 알고리즘으로 풀어야겠다"가 보임!**  
✔ **문제를 많이 풀면서 경험을 쌓아야 더 빠르게 선택할 수 있음.**

